(in-package :rogue-test)

;;; Styles:
;;; dungeon - your normal run-of-the-mill dungeon room: a bunch of rooms connected by tunnels

(defmacro loop-in-map ((pos map &optional (offset nil offset-p) (dimensions nil dimensions-p))
		       &body body)
  (let ((range (gensym))
	(begin (gensym))
	(x (gensym))
	(y (gensym)))
    `(let* ((,begin ,(if offset-p offset '(p 0 0)))
	    (,range (pos+ ,begin ,(if dimensions-p dimensions `(pos- (array-dimensions ,map) (list 1 1))))))
       (loop for ,x from (x ,begin) to (w ,range)
	     do (loop for ,y from (y ,begin) to (h ,range)
		      do (let ((,pos (list ,x ,y)))
			   ,@body))))))

(defun draw-level (level cam-pos scr-dims) 
  (loop-in-map (pos level (p 0 0) scr-dims)
    (when  (pos-in-range pos level)
      (let ((sym (case (mapref level pos)
		   (:room #\.)
		   (:wall #\W)
		   (:maze #\#)
		   (:maze-filled #\~)
		   (:dbg #\$)
		   (:door #\=)
		   (t #\ ))))
	(move (+ (- (y pos) (y cam-pos)) (truncate (h scr-dims) 2))
	      (+ (- (x pos) (x cam-pos)) (truncate (w scr-dims) 2)))
	(addch (char-code sym))))))

(defun mapref (map position)
  (aref map (x position) (y position)))

(defun (setf mapref) (value map position)
  (setf (aref map (x position) (y position)) value))

;; (defparameter dim-roll :3d4+2)
;; (defparameter dist-roll :d10+3)

(defparameter dim-roll :2d4+4)
(defparameter min-dist 1)

(defun update-pos-val (level pos value min-dist)
  (when (and (not (zerop (1- value)))
	     (pos-in-range pos level))
    (let ((pos-value (if (not (numberp (mapref level pos))) min-dist
			 (mapref level pos))))
      (when (< pos-value (1- value))
	(prog1 (setf (mapref level pos) (1- value))
	  (fill-adjacent level pos min-dist))))))

(defun fill-adjacent (level pos min-dist)
  (let ((pos-value (if (not (numberp (mapref level pos))) (1+ min-dist)
		       (mapref level pos))))
    (when (not (zerop pos-value))
      (some #'(lambda (i) i)
	    (list (update-pos-val level (pos+dir pos :up)  pos-value min-dist)
		  (update-pos-val level (pos+dir pos :down) pos-value min-dist)
		  (update-pos-val level (pos+dir pos :left) pos-value min-dist)
		  (update-pos-val level (pos+dir pos :right) pos-value min-dist))))))

(defun fill-deadzone (level min-dist)
  (let ((tmp (alexandria:copy-array level)))
    (let ((modified t))
      (loop while modified
	    do (loop-in-map (pos level)
		 (setf modified (fill-adjacent tmp pos min-dist)))))
    tmp))

(defun filled-p (level position)
  (not (eq 0 (aref level (x position) (y position)))))

(defun collides-p (level position dimensions)
  (block loop
    (loop-in-map (pos level position dimensions)
      (when (filled-p level pos)
	(return-from loop pos)))))

(defun pos-in-rect (pos dims offset)
  (and (in-range (x pos) 0 (+ (x offset) (w dims)))
       (in-range (y pos) 0 (+ (y offset) (h dims)))))

(defun pos-in-range (pos level)
  (and (in-range (x pos) 0 (1- (array-dimension level 0)))
       (in-range (y pos) 0 (1- (array-dimension level 1)))))

(defun eq-at-offset (level pos offset value)
  (let ((new-pos (list (+ (x pos) (x offset)) (+ (y pos) (y offset)))))
    (and (pos-in-range new-pos level)
	 (eq value (aref level (x new-pos) (y new-pos))))))

(defun paint-room (level room)
  (let ((position (getf room :pos))
	(size (pos- (getf room :size) (p 1 1))))
    (loop-in-map (pos level position size)
      (if (or (= (x pos) (x position))
	      (= (y pos) (y position))
	      (= (x pos) (+ (x position) (w size)))
	      (= (y pos) (+ (y position) (h size))))
	  (setf (mapref level pos) :wall)
	  (setf (mapref level pos) :room)))))

(defun gen-rooms-2 (amount)
  (flet ((room-collide-p (a b)
	   (let* ((a-a (getf a :pos))
		  (a-b (getf a :size))
		  (b-a (getf b :pos))
		  (b-b (getf b :size)))
	     (and (or (in-range (x a-a) (x b-a) (x b-b))
		      (in-range (x a-b) (x b-a) (x b-b))
		      (in-range (x b-a) (x a-a) (x a-b))
		      (in-range (x b-b) (x a-a) (x a-b)))
		  
		  (or (in-range (y a-a) (y b-a) (y b-b))
		      (in-range (y a-b) (y b-a) (y b-b))
		      (in-range (y b-a) (y a-a) (y a-b))
		      (in-range (y b-b) (y a-a) (y a-b)))))))
    (let ((rooms nil)
	  (min-x 0)
	  (min-y 0)
	  (max-x 0)
	  (max-y 0)
	  (o-x 0)
	  (o-y 0)
	  (e-x 0)
	  (e-y 0))
      (loop for size = (p (roll-dice dim-roll) (roll-dice dim-roll))
	    for pos = (list (- (random-range o-x e-x) (half-w size))
			    (- (random-range o-y e-y) (half-h size)))
	    for room = (list :pos pos :size size :n (length rooms))
	    for i from 0
	    if (notany #'(lambda (room-b) (room-collide-p room room-b)) rooms)
	      do (progn (push room rooms)
			(setf max-x (max max-x (+ (x pos) (w size))))
			(setf max-y (max max-y (+ (y pos) (h size))))
			(setf min-x (min min-x (x pos)))
			(setf min-y (min min-y (y pos))))
	    else
	      do (progn (= i 100)
			(setf i 0)
			(decf o-x)
			(decf o-y)
			(incf e-x)
			(incf e-y))
	    until (zerop (- (length rooms) amount)))
      (loop for room in rooms
	    do (setf (getf room :pos) (pos- (getf room :pos) (p min-x min-y))))
      (let ((level (make-array (pos- (p max-x max-y) (p min-x min-y)) :initial-element nil)))
	(list :level level :rooms rooms)))))

(defun print-level (level)
  (loop for y from 0 to (1- (array-dimension level 1))
  	do (loop for x from 0 to (1- (array-dimension level 0))
  		 do (let ((sym (case (aref level x y)
				 (:room #\.)
				 (:wall #\W)
				 (:maze #\#)
				 (:maze-filled #\~)
				 (:dbg #\$)
				 (:door #\=)
				 (t #\ ))))
		      (format t "~a" sym)))
  	   (terpri)))


(defun fill-pathways-candidates (level ))

(defun find-adjacent (level position &rest values)
  (loop for dir in '(:up :down :left :right)
	for pos = (pos+ position (direction-delta dir))
	if (and (pos-in-range pos level)
		(find (aref level (x pos) (y pos)) values))
	  collect pos))

(defun find-at (level position directions &rest values)
  (loop for dir in directions
	for pos = (pos+ position (direction-delta dir))
	if (and (pos-in-range pos level)
		(find (mapref level pos) values))
	  collect pos))

(defun count-at (level position directions value)
  (loop for dir in directions
	for pos = (pos+dir position dir)
	if (and (pos-in-range pos level)
		(equal value (mapref level pos)))
	  summing 1))

(defun filled-at (level pos direction)
  (filled-p level (pos+ pos (direction-delta direction))))

(defun level-at (level position)
  (aref level (x position) (y position)))

(defun set-at (level position dir value)
  (let ((pos (pos+ position (direction-delta dir))))
    (setf (aref level (x pos) (y pos)) value)))

(defun dir-in-range (level position dir)
  (let ((pos (pos+dir position dir)))
    (and (in-range (x pos) 0 (1- (array-dimension level 0)))
	 (in-range (y pos) 0 (1- (array-dimension level 1))))))

(defun eq-at (level position dir value)
  (eq-at-offset level position (direction-delta dir) value))

(defun random-elt (seq)
  (elt seq (random (length seq))))

(defun can-put-maze (level pos)
  )

(defun id (value)
  value)

(defun can-branch-maze (level position dir)
  (let ((pos (pos+dir position dir)))
    (and (pos-in-range pos level)
	 (not (mapref level pos))
	 (zerop (count-at level pos *dirs* :room))
	 (let ((ajdacent-old (find-adjacent level position :maze))
	       (ajdacent-new (find-at level pos (remove (direction-opposite dir) *dirs*) :maze)))
	   (every #'(lambda (pos) (find pos ajdacent-old :test 'equal))
		  ajdacent-new)))))

(defun direction-pool (level position)
  (remove-if-not #'(lambda (dir) (can-branch-maze level position dir)) *axises*))

(defun choose-direction (level pos)
  (let ((pool (direction-pool level pos)))
    (when pool (random-elt pool))))

(defun gen-pasage (level position)
  (let ((pos (copy-seq position))
	(branch-targets nil))
    (loop for dir = (choose-direction level pos)
	  while dir
	  do (loop for pool = (direction-pool level pos)
		   do (setf (mapref level pos) :maze)
		   while (and (roll-above :d1000 250)
			      (can-branch-maze level pos dir))		   
		   do (when (> (length pool) 1)
			(push (list pos pool) branch-targets))		      
		      (setf pos (pos+dir pos dir))))
    (loop while branch-targets
	  for target = (random-elt branch-targets)
	  do (mapcar #'(lambda (dir)
			 (gen-pasage level (pos+dir (first target) dir)))
		     (second target))
	     (setf branch-targets (delete target branch-targets)))))

(defun map-dirs (pos dirs)
  (mapcar #'(lambda (dir) (pos+dir pos dir)) dirs))

(defun gen-passages (level)
  (loop-in-map (pos level)
    (when (and (not (mapref level pos))
	       (zerop (+ (count-at level pos *dirs* :room)
			 (count-at level pos *dirs* :wall)
			 (count-at level pos *dirs* :maze))))
      (gen-pasage level pos))))

(defun dbg-print-pos (level pos)
  ;; (let ((tmp (alexandria:copy-array level)))
  ;;   (setf (mapref tmp pos) :dbg)
  ;;   (print-level tmp)
  ;;   (sleep 0.1)
  ;;   (terpri))
  )

(defun pos-in-room (pos room)
  (let ((room-pos (getf room :pos))
	(size (getf room :size)))
    (and (in-range (x pos) (x room-pos) (w size))
	 (in-range (y pos) (y room-pos) (h size)))))

(defun corner-p (level pos)
  (and (= (count-at level pos *axises* :wall) 2)
       (= (count-at level pos *diags* :room) 1)
       (= (count-at level pos *axises* :room) 0)))

(defun walk-maze (start room rooms level)
  (let ((connections (make-hash-table))
	(deadends nil))
    (let* ((tmp (alexandria:copy-array (getf level :level)))
	   (branches nil)
	   (pos (first (find-at tmp start *axises* :maze)))
	   (dist 0))
      (loop while (and pos (not (eq (mapref tmp pos) :maze-filled)))
	    do (setf (mapref tmp pos) :maze-filled)
	       (let ((adj (first (find-at tmp pos *axises* :wall))))
		 (when (and adj
			    (not (pos-in-room adj room))
			    (not (corner-p tmp adj))
			    (= (count-at tmp pos *axises* :room) 0))
		   (let ((room-b (find-if #'(lambda (room)
					      (pos-in-room adj room))
					  rooms)))
		     (let ((val (gethash (getf room-b :n) connections)))
		       (when (or (not val)
				 (< dist (getf val :dist)))
			 (setf (gethash (getf room-b :n) connections)
			       (list :rooms (sort (list (getf room :n) (getf room-b :n)) #'<)
				     :dist dist
				     :start start
				     :end adj))))))
		 (incf dist))
	       (let ((next-pos (find-at tmp pos *axises* :maze)))
		 (if next-pos
		     (progn (setf pos (car next-pos))			    
			    (loop for branch in (cdr next-pos)
				  do (push (list branch dist) branches)))
		     (progn
		       (setf deadends (adjoin pos deadends :test #'equal))
		       (when branches
			 (setf pos (first (car branches))
			       dist (second (car branches))
			       branches (cdr branches))))))))
    (list :connections (alexandria:hash-table-values connections)
	  :deadends deadends)))

(defun gen-connections (level)
  (let ((connections (make-hash-table :test #'equal))
	(deadends nil))
   (loop for room in (getf level :rooms)
	 for pos = (getf room :pos)
	 for size = (getf room :size)
	 for x = (1+ (x pos))
	 for y = (y pos)
	 for i from 0
	 do (flet ((walk ()
		     (let ((result (walk-maze (list x y) room (remove room (getf level :rooms)) level)))
		       (loop for con in (getf result :connections)			    
			     for val = (gethash (getf con :rooms) connections)
			     if (or (not val)
				    (< (getf con :dist) (getf val :dist)))
			       do (setf (gethash (getf con :rooms) connections) con))
		       (loop for deadend in (getf result :deadends)
			     do (setf deadends (adjoin deadend deadends :test #'equalp))))))
	      (loop do (incf x)
		    while (< (- x (x pos)) (1- (w size)))
		    do (walk))
	      (loop do (incf y)
		    while (< (- y (y pos)) (1- (h size)))
		    do (walk))
	      (loop do (decf x)
		    while (> (- x (x pos)) 0)
		    do (walk))
	      (loop do (decf y)
		    while (> (- y (y pos)) 0)
		    do (walk))))
    (loop for con in (alexandria:hash-table-values connections)
	  if (= (count-at (getf level :level) (getf con :start) *axises* :door) 0)
	    do (setf (mapref (getf level :level) (getf con :start)) :door)
	  if (= (count-at (getf level :level) (getf con :end) *axises* :door) 0)
	    do (setf (mapref (getf level :level) (getf con :end)) :door))
    deadends))

(defun remove-deadends (level deadends)
  (loop for pos in deadends
	do (loop while (and (= (count-at level pos *axises* :maze) 1)
			    (= (count-at level pos *axises* :door) 0))
		 do (dbg-print-pos level pos)
		    (setf (mapref level pos) nil
			  pos (first (find-at level pos *axises* :maze))))))

(defun add-random-doors (level)
  (loop-in-map (pos level)
    (if (and (not (mapref level pos))
	     (= (count-at level pos *axises* :maze) 2)
	     (= (count-at level pos *axises* :door) 0)
	     (or (= (count-at level pos '(:left :right) :maze) 2)
		 (= (count-at level pos '(:up :down) :maze) 2))
	     (toss-coin)
	     (toss-coin)
	     (toss-coin))
	(setf (mapref level pos) :maze))))

(defun gen-labyrinth (level)
  (gen-passages (getf level :level))
  (remove-deadends (getf level :level) (gen-connections level))
  ;; (add-random-doors (getf level :level))
  )

(defun generate-dungeon (n-rooms)
  (let* ((level (gen-rooms-2 n-rooms)))
    (loop for room in (getf level :rooms)
	  do (paint-room (getf level :level) room))
    (gen-labyrinth level)
    (print-level (getf level :level))
    (getf level :level)))

(defun generate-topology (number-of-rooms &optional (style :dungeon))
  (case style
    (:dungeon (generate-dungeon number-of-rooms))))

;; (defun gen-level (number-of-rooms challenge-rating style))
